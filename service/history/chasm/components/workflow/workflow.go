package workflow

import (
	"time"

	"go.temporal.io/server/api/matchingservice/v1"
	"go.temporal.io/server/api/persistence/v1"
	"go.temporal.io/server/service/history/chasm"
	"go.temporal.io/server/service/history/chasm/components/activity"
	"go.temporal.io/server/service/history/chasm/components/callback"
	"go.temporal.io/server/service/history/consts"
)

type (
	WorkflowImpl struct {
		WorkflowInfo persistence.WorkflowExecutionInfo

		Activities chasm.DataMap[*activity.ActivityImpl]
	}
)

func NewWorkflow(
	chasmContext chasm.MutableContext,
	request *NewWorkflowRequest,
) (*WorkflowImpl, *NewWorkflowResponse, error) {
	workflow := &WorkflowImpl{
		WorkflowInfo: persistence.WorkflowExecutionInfo{}, // populate some fields
	}

	if err := chasmContext.AddTask(
		chasm.Task{
			Attributes: chasm.TaskAttributes{
				ScheduledTime: chasmContext.Now().Add(time.Hour),
			},
			Data: WorkflowTimeoutTask{},
		},
	); err != nil {
		return nil, nil, err
	}
	if err := chasmContext.AddTask(
		chasm.Task{
			Attributes: chasm.TaskAttributes{},
			Data:       DispatchWorkflowTask{},
		},
	); err != nil {
		return nil, nil, err
	}

	return workflow, &NewWorkflowResponse{}, nil
}

func (w *WorkflowImpl) RunningState() chasm.ComponentState {
	panic("not implemented")
}

func (w *WorkflowImpl) wrapActivityTasks(
	t chasm.Task,
	activityID string,
) chasm.Task {
	switch t.Data.(type) {
	case activity.DispatchTask:
		t.Data = ActivityDispatchTask{
			ActivityID:   activityID,
			DispatchTask: t.Data.(activity.DispatchTask),
		}
		return t
	case activity.TimeoutTask:
		// omitted
		return t
	default:
		panic("unknown activity task type")
	}
}

func (w *WorkflowImpl) RespondWorkflowTaskCompleted(
	chasmContext chasm.MutableContext,
	request *RespondWorkflowTaskCompletedRequest,
) (*RespondWorkflowTaskCompletedResponse, error) {
	for _, command := range request.ActivityCommands {
		// NOTE this will generate tasks,
		// but workflow should define handlers for these tasks.

		// Goal here is to wrap the task generated by activity component with
		// additional data: activityID in this case.

		// either we separate state change and task generation
		a := &activity.ActivityImpl{}
		a.UpdateStateToScheduled(chasmContext, &activity.ScheduleRequest{})
		for _, t := range a.GenerateScheduledTasks(chasmContext) {
			if err := chasmContext.AddTask(
				w.wrapActivityTasks(t, command.ActivityID),
			); err != nil {
				return nil, err
			}
		}

		// or specify a task wrapper, then we can reuse methods from activity
		activityContext := chasmContext.WithTaskWrapper(func(task chasm.Task) chasm.Task {
			return w.wrapActivityTasks(task, command.ActivityID)
		})
		a, _, err := activity.NewScheduledActivity(
			activityContext,
			&activity.NewActivityRequest{},
		)
		if err != nil {
			return nil, err
		}

		w.Activities[command.ActivityID] = chasm.NewDataField(chasmContext, a)
	}
	return &RespondWorkflowTaskCompletedResponse{}, nil
}

func (w *WorkflowImpl) LoadActivityDispatchInfo(
	chasmContext chasm.Context,
	activityID string,
) (*matchingservice.AddActivityTaskRequest, error) {

	a, err := w.Activities[activityID].Get(chasmContext)
	if err != nil {
		return nil, err
	}

	return a.LoadDispatchInfo(chasmContext, struct{}{})
}

func (w *WorkflowImpl) LoadActivityCallbackInvocationInfo(
	chasmContext chasm.Context,
	activityID string,
) (*callback.InvocationInfo, error) {

	a, err := w.Activities[activityID].Get(chasmContext)
	if err != nil {
		return nil, err
	}

	// NOTE: we are directly accessing a.Callback.
	// This should be a implementation detail of activity component.
	// including the fact that it has a callback.
	callback, err := a.Callback.Get(chasmContext)

	return callback.LoadInvocationInfo(chasmContext)
}

// point is that this API is defined on workflow, not activity.
// Activity component service can still define a reuseable api to complete activity
// given a Ref. i.e. workflow doesn't need to re-define completeActivity, that's already
// defined on activity component and SDK worker can just invoke that api since it has the ref.
// But any byID activity can only be defined on Instances (top level).
func (w *WorkflowImpl) CompleteActivityByID(
	chasmContext chasm.MutableContext,
	request *CompleteActivityByIDRequest,
) (*CompleteActivityByIDResponse, error) {

	if w.RunningState() != chasm.ComponentStateRunning {
		return nil, consts.ErrWorkflowCompleted
	}

	a, err := w.Activities[request.ActivityID].Get(chasmContext)
	if err != nil {
		return nil, err
	}

	if _, err = a.RecordCompleted(chasmContext, &activity.RecordCompletedRequest{}); err != nil {
		return nil, err
	}

	// continue to schedule workflow task

	// remove activity
	delete(w.Activities, request.ActivityID)

	return nil, nil
}

func (w *WorkflowImpl) CompleteActivity(
	chasmContext chasm.MutableContext,
	request *CompleteActivityRequest,
) (*CompleteActivityResponse, error) {

	var activityToken ActivityToken
	if err := activityToken.Deserialize(request.SerializedActivityToken); err != nil {
		return nil, err
	}

	a, err := w.Activities[activityToken.ActivityID].Get(chasmContext)
	if err != nil {
		return nil, err
	}

	activityResp, err := a.RecordCompleted(chasmContext, &activity.RecordCompletedRequest{
		Output: request.Output,
	})

	// schedule workflow task here

	// remove activity
	delete(w.Activities, activityToken.ActivityID)

	return &CompleteActivityResponse{
		RecordCompletedResponse: activityResp,
	}, nil
}

type WorkflowTimeoutTask struct{}
type DispatchWorkflowTask struct{}

type NewWorkflowRequest struct{}
type NewWorkflowResponse struct{}

type ActivityCommand struct {
	ActivityID string
	Input      []byte
}

type RespondWorkflowTaskCompletedRequest struct {
	ActivityCommands []ActivityCommand
}

type RespondWorkflowTaskCompletedResponse struct{}

type CompleteActivityByIDRequest struct {
	RefToken   []byte
	ActivityID string
	Output     []byte
}
type CompleteActivityByIDResponse struct{}
